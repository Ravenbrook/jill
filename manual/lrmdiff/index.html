<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>

<title>Lua Reference Manual Differences</title>

</head>

<body bgcolor="#FFFFFF" text="#000000" link="#000099" vlink="#660066" alink="#FF0000">

<div align="center">

<p>
<a href="/">Ravenbrook</a> /
<a href="/project/">projects</a> /
<a href="/project/jili/">Java Implementation of Lua for Intuwave</a>
</p>

<hr />
<h1>Lua Reference Manual Differences</h1>

<address>
<a href="mailto:drj@ravenbrook.com">David Jones</a>,
<a href="http://www.ravenbrook.com/">Ravenbrook Limited</a>,
2006-05-22
</address>

</div>

<h2>Introduction</h2>

<p>
This document describes the differences between PUC-Rio's implementation
of Lua and Jili.  It is structured to follow PUC-Rio's LRM.
</p>

<p>
This document is a work in progress.  As of 2006-05-22 the LRM is
covered up to (but not including) section 3.8.
</p>

<h2>LRM Section 2 - The Language</h2>

<p>
Essentially identical except that in Jili source chunks are sequences of
Unicode characters.  Similarly, in Jili strings are sequences of Unicode
characters.  Binary chunks are sequences of bytes.
</p>

<p>
Lua supports strings escapes for <code>\a</code> and <code>\v</code>
which are not present in Java.  They map to <code>char</code>s with
value 7 and 11 respectively.  Which is what most C implementations using
ASCII would map them to.
</p>

<dl>
  <dt>LRM 2.2</dt> <dd>Jili only has one sort of userdata (implemented
  by the <code>LuaUserdata</code> class).  Therefore all facilities
  concerned with light userdata are removed.</dd>
  <dt>LRM 2.2.1</dt> <dd>The conversion of strings to numbers and
  numbers to strings in Jili may be slightly different from the
  corresponding conversions in PUC-Rio Lua.  For example, the value
  <code>(1 - 1e-16)</code> is converted to "1" in a stock version of
  PUC-Rio Lua 5.1 running on a reasonable quality C implementation.  In
  Jili the same value is converted to "0.9999999999999999".  Also the
  number <code>-0</code> is converted to "-0" in Jili, and "0" in
  PUC-Rio.
  Jili uses Java's underlying conversion mechanisms which are more
  precisely specified than C.</dd>
  <dt>LRM 2.10</dt> <dd>GC provided by JVM</dd>
  <dt>LRM 2.10.1</td> <dd><code>__gc</code> metamethod not
    supported.</dd>
  <dt>LRM 2.10.2</dt> <dd><code>__mode</code> metamethod not
    supported.</dd>
</dl>

<h2>LRM Section 3 - The Application Program Interface</h2>

<p>
Obviously different as the PUC-Rio API is in C and Jili's API is in
Java.  Equivalent facilities are provided.  In the list below, only
those API facilities that are significantly different from PUC-Rio are
mentioned.  Generally the C API function <code>lua_XXX</code> becomes a
method in the <code>Lua</code> class called <code>XXX</code> with the
capitalisation modified to meet prevalent Java standards.
</p>

<dl>
  <dt>LRM 3.1</dt>
  <dd>The stack is retained but only for passing arguments
  to functions and receiving their return values.  Methods in Jili's API
  generally receive and return Lua objects directly as Java objects.
  </dd>

  <dt>LRM 3.4</dt>
  <dd>C closures are replaced with instances of
  <code>LuaJavaCallback</code> which is subclassed and instantiated by
  clients of Jili's API.
  </dd>

  <dt>LRM 3.5</dt>
  <dd>(The Registry) Court still in session.</dd>

  <dt>(Error Handling) LRM 3.6</dt>
  <dd>As in PUC-Rio Lua errors should be handled using
  <code>pcall</code>.  Internally errors are generated using Java
  exceptions, so Lua errors that occur outside of the environment
  created by <code>pcall</code> will manifest as Java exceptions.  Most
  of Java's internal exceptions are not caught so will be passed through
  transparently.  In particular running out of memory in Lua will appear
  as the usual Java exception.
  </dd>

  <dt>lua_Alloc</dt>
  <dd>No equivalent in Jili.</dd>

  <dt>lua_atpanic</dt>
  <dd>No equivalent in Jili.  A Lua error raised outside the environment
  created by <code>pcall</code> will manifest as a Java exception being
  thrown.</dd>

  <dt>lua_CFunction</dt>
  <dd>Replace by <code>LuaJavaCallback</code>.</dd>

  <dt>lua_checkstack</dt>
  <dd>Same.  Or maybe unnecesssary.</dd>

  <dt>lua_close</dt>
  <dd>Provided, but does nothing (would call GC metamethods if they were
  supported).</dd>

  <dt>lua_cpcall</dt>
  <dd>There is no direct equivalent, use <code>pcall</code> instead.</dd>

  <dt>lua_gc</dt>
  <dd>Same interface but mostly dummy functionality.</dd>

  <dt>lua_getallocf</dt>
  <dd>No equivalent.</dd>

  <dt>lua_getfield</dt>
  <dd>Same.  <code>LUA_GLOBALSINDEX</code>,
  <code>LUA_ENVIRONINDEX</code>, <code>LUA_REGISTRYINDEX</code>, not
  supported.  See <code>getGlobals</code>, <code>getEnviron</code>,
  <code>getRegistry</code> instead.</dd>

  <dt>lua_integer</dt>
  <dd>Replaced by <code>int</code>.</dd>

  <dt>lua_iscfunction</dt>
  <dd>Use <code>isJavaFunction</code>.</dd>

  <dt>lua_islightuserdata</dt>
  <dd>No equivalent as Jili does not have light userdata.</dd>

  <dt>lua_load</dt>
  <dd>Similar, see <code>Lua.load</code>.</dd>

  <dt>lua_newstate</dt>
  <dd>Use constructor of <code>Lua</code>.</dd>

  <dt>lua_next</dt>
  <dd>Same, but not efficient.</dd>

  <dt>lua_Number</dt>
  <dd>Modelled by <code>java.lang.Double</code>.</dd>

  <dt>lua_objlen</dt>
  <dd>Same, except that it returns 0 for userdata.</dd>

  <dt>lua_pushcclosure</dt>
  <dd>Use generic push with a <code>LuaJavaCallback</code> instance.</dd>

  <dt>lua_pushcfunction</dt>
  <dd>As for <code>lua_pushcclosure</code>.</dd>
  
  <dt>lua_pushfstring</dt>
  <dd>Not provided.  Generally you can use Java's <code>+</code>
  operator on <code>String</code> to build complex strings.</dd>

  <dt>lua_pushinteger</dt>
  <dd>Use <code>Lua.pushNumber</code>.</dd>

  <dt>lua_pushlightuserdata</dt>
  <dd>No equivalent as Jili does not have light userdata.</dd>

  <dt>lua_pushlstring</dt>
  <dd>Use <code>Lua.pushString</code>.</dd>

  <dt>lua_pushvfstring</dt>
  <dd>Not provided.</dd>

  <dt>lua_Reader</dt>
  <dd>Generally replaced with <code>java.io.InputStream</code>.</dd>

  <dt>lua_register</dt>
  <dd>To be decided.</dd>

  <dt>lua_remove</dt>
  <dd>No equivalent.</dd>

  <dt>lua_replace</dt>
  <dd>No equivalent.</dd>

  <dt>lua_setallocf</dt>
  <dd>No equivalent.</dd>

  <dt>lua_setfield</dt>
  <dd>Same. See <code>lua_getfield</code>.</dd>

  <dt>lua_State</dt>
  <dd>The Jili equivalent is the <code>Lua</code> class.</dd>

  <dt>lua_tocfunction</dt>
  <dd>No equivalent (cast to <code>LuaJavaCallback</code>).</dd>
  
  <dt>lua_tointeger</dt>
  <dd>Same. Conversion as per <a href="#ref-jls">JLS</a> 5.1.3</dd>

  <dt>lua_tolstring</dt>
  <dd>No equivalent.  Use <code>Lua.toString</code> instead.</dd>

  <dt>lua_topointer</dt>
  <dd>No.  Cast to <code>Object</code> if you must.</dd>

  <dt>lua_tostring</dt>
  <dd>Same.  Obviously, does not modify the stack.</dd>

  <dt>lua_Writer</dt>
  <dd>Generally replaced with <code>java.io.OutputStream</code>.</dd>

</dl>

<h2 id="section-5">5. Standard Libraries</h2>

<dl>

<dt>rawset</dt>
<dd>In Jili this does not return a value.</dd>

<dt>_VERSION</dt>
<dd>Exists and is a string, as in PUC-Rio, but its contents will be
different.</dd>

<dt>string.byte</dt>
<dd>Internal numerical codes are Unicode code positions -
values from the Java type
<code>char</code>.  The name is unfortunate, think of it as a 16-bit
byte if you like.
</dd>

<dt>string.char</dt>
<dd>As for <code>string.byte</code> the internal numerical codes are
Unicode code positions.
</dd>

<dt>os.clock</dt>
<dd>Returns wall clock time since the class that implements the function
was loaded.</dd>

</dl>


<h2 id="section-A">A. References</h2>

<table>

<tr valign="top">
    <td>[<a id="ref-lrm">LRM</a>]</td>
    <td>Lua 5.1 Reference Manual; Roberto Ierusalimschy, Luiz Henrique
    de Figueiredo, Waldemar Celes; &lt;URL: <a
    href="http://www.lua.org/manual/5.1/manual.html">http://www.lua.org/manual/5.1/manual.html"</a>
    &gt;; 2006</td>
</tr>

<tr valign="top">
    <td>[<a id="ref-jls">JLS</a>]</td>
    <td>"The Java Language Specification, Second Edition";
    James Gosling,
    Bill Joy,
    Guy Steele,
    Gilad Bracha; 2000-06-05;
    &lt;URL: <a
    href="http://java.sun.com/docs/books/jls/">http://java.sun.com/docs/books/jls/</a>&gt;
    </td>
</tr>
  
</table>

<h2 id="section-B">B. Document History</h2>

<table>

<tr valign="top">
    <td>2006-05-22</td>
    <td><a href="mailto:drj@ravenbrook.com">DRJ</a></td>
    <td>Created.</td>
</tr>

<tr valign="top">
    <td>2006-07-06</td>
    <td><a href="mailto:drj@ravenbrook.com">DRJ</a></td>
    <td>More doc.</td>
</tr>

</table>

<h2 id="section-C">C. Copyright and Licence</h2>

<p>
Copyright &copy; 2006 Ravenbrook Limited.  Intuwave Client
Confidential.
</p>

<hr />

<div align="center">
<p><code>$Id$</code></p>

<p>
<a href="/">Ravenbrook</a> /
<a href="/project/">projects</a> /
<a href="/project/jili/">Java Implementation of Lua for Intuwave</a>
</p>

</div>

</body>
</html>
